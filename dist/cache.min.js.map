{"version":3,"file":"cache.min.js","sources":["../src/cache.js","../src/cache-storage.js"],"sourcesContent":["const map = new WeakMap()\nconst wm = o => map.get(o)\n\nconst requires = (i, args) => {\n  if (args.length < i)\n    throw new TypeError(`${i} argument required, but only ${args.length} present.`)\n}\n\nconst isReq = req => req && req instanceof Request\nconst isRes = res => res && res instanceof Response\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = () => {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', { keyPath: 'cacheName' })\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass Cache {\n  constructor(cacheName) {\n    map.set(this, cacheName)\n  }\n\n  /**\n   * Returns a Promise that resolves to the response associated\n   * with the first matching request in the Cache object.\n   *\n   * @param  {[type]}  args [description]\n   * @return {Promise}      [description]\n   */\n  async match(...args) {\n    return (await this.matchAll(...args))[0]\n  }\n\n  // Returns a Promise that resolves to an array\n  // of all matching requests in the Cache object.\n  async matchAll(req, options = {}) {\n    if (req.method === 'HEAD') return []\n\n    const cacheName = wm(this)\n    const db = await openDB()\n    const result = []\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readonly')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const request = index.openCursor(IDBKeyRange.only(cacheName));\n    request.onsuccess = function() {\n      let cursor = this.result;\n\n      if (cursor) {\n        if ((req.url || req) === cursor.value.reqUrl) {\n          const initData = Object.assign({\n            url: cursor.value.resUrl\n          }, cursor.value)\n\n          const res = new Response(cursor.value.body, initData)\n          result.push(res)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(result)\n    )\n  }\n\n  // Takes a URL, retrieves it and adds the resulting response\n  // object to the given cache. This is fuctionally equivalent\n  // to calling fetch(), then using put() to add the results to the cache\n  async add(request) {\n    requires(1, arguments)\n    return this.addAll([request])\n  }\n\n  // Takes an array of URLs, retrieves them, and adds the\n  // resulting response objects to the given cache.\n  async addAll(requests) {\n    requires(1, arguments)\n\n    let results = []\n\n    for (let req of requests) {\n      req = new Request(req)\n\n      if (!/^((http|https):\\/\\/)/.test(req.url))\n        throw new TypeError(`Add/AddAll does not support schemes other than \"http\" or \"https\"`)\n\n      if (req.method !== 'GET')\n        throw new TypeError(`Add/AddAll only supports the GET request method`)\n\n      let clone = req.clone()\n\n      await fetch(req).then(res => {\n        if (res.status === 206)\n          throw new TypeError('Partial response (status code 206) is unsupported')\n\n        if (!res.ok)\n          throw new TypeError('Request failed')\n\n        results.push([req, res])\n      })\n    }\n\n    await Promise.all(results.map(a => this.put(...a)))\n  }\n\n\n  /**\n   * Takes both a request and its response and adds it to the given cache.\n   *\n   * @param  {Request|String}  req  [description]\n   * @param  {Response}        res  [description]\n   * @return {Promise}              [description]\n   */\n  async put(req, res) {\n    requires(2, arguments)\n\n    req = isReq(req) ? req : new Request(req)\n\n    await this.delete(req)\n\n    if (!/^((http|https):\\/\\/)/.test(req.url))\n      throw new TypeError(`Request scheme '${req.url.split(':')[0]}' is unsupported`)\n\n    if (req.method !== 'GET')\n      throw new TypeError(`Request method '${req.method}' is unsupported`)\n\n    if (res.status === 206)\n      throw new TypeError('Partial response (status code 206) is unsupported')\n\n    let varyHeaders = res.headers.get('Vary')\n\n    if (varyHeaders && varyHeaders.includes('*'))\n      throw new TypeError('Vary header contains *')\n\n    if (res.body != null)\n      if (res.bodyUsed)\n        throw new TypeError('Response body is already used')\n\n    let folder = wm(this)\n    let cache = {\n      cacheName: folder,\n      headers: [...res.headers],\n      status: res.status,\n      statusText: res.statusText,\n      body: await res.arrayBuffer(),\n      reqUrl: req.url.replace(/#.*$/,''),\n      resUrl: res.url.replace(/#.*$/,''),\n      reqMethod: req.method\n    }\n\n    const db = await openDB()\n\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('caches', 'readwrite')\n      const store = tx.objectStore('caches')\n\n      // Add some data\n      store.put(cache);\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n  }\n\n  // Finds the Cache entry whose key is the request, and if found,\n  // deletes the Cache entry and returns a Promise that resolves to true.\n  // If no Cache entry is found, it returns false.\n  async delete(request, options = {}) {\n    requires(1, arguments)\n    const cacheName = wm(this)\n\n    const { ignoreMethod } = options\n    const r = isReq(request) ? request : new Request(request)\n    if (!['GET', 'HEAD'].includes(r.method) && ignoreMethod)\n      return false\n\n    const { method } = r\n    const url = r.url.replace(/#.*$/,'')\n    const db = await openDB()\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readwrite')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const query = index.openCursor(IDBKeyRange.only(cacheName));\n\n    let deleted = false\n\n    query.onsuccess = function() {\n      const cursor = this.result;\n\n      if (cursor) {\n        if (url === cursor.value.reqUrl && (ignoreMethod || method === cursor.value.reqMethod)) {\n          deleted = true\n          caches.delete(cursor.primaryKey)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(deleted)\n    )\n  }\n\n  // Returns a Promise that resolves to an array of Cache keys.\n  async keys(request, options = {}) {\n    let url\n    const folder = wm(this)\n    const {\n      ignoreMethod = false,\n      ignoreSearch = false\n    } = options\n\n    // using new Request to normalize fragment and trailing slash\n    if (request !== undefined) {\n      request = new Request(request)\n\n      url = request.url.split('#')[0]\n\n      if (request.method !== 'GET' && !ignoreMethod) return []\n    }\n\n    const search = request === undefined ? a => a : a => a.filter(a => {\n      if (ignoreSearch) {\n        a = a.reqUrl.split('?')[0]\n        url = url.split('?')[0]\n      } else {\n        a = a.reqUrl\n      }\n\n      return a === url\n    })\n\n    const db = await openDB()\n\n    const responses = await new Promise(rs => {\n      const tx = db.transaction('caches', 'readonly')\n      const store = tx.objectStore('caches')\n      const cacheName = store.index('cacheName');\n      const request = cacheName.getAll(IDBKeyRange.only(folder))\n      request.onsuccess = () => rs(request.result)\n    })\n\n    return search(responses).map(response => new Request(response.reqUrl))\n  }\n}\n\nmodule.exports = Cache\n","const Cache = require('./cache')\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = function() {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', {keyPath: 'cacheName'})\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      const e = cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass CacheStorage {\n\n  /**\n   * [delete description]\n   * @return {[type]} [description]\n   */\n  async delete(cacheName) {\n    // Should resolve to false if there is nothing to delete\n    const keys = await this.keys()\n    if (!keys.includes(cacheName)) {\n      return false\n    }\n\n    const db = await openDB()\n\n    // Start a new transaction\n    var tx = db.transaction(['storages', 'caches'], 'readwrite')\n    var store = tx.objectStore('storages')\n    var request = store.delete(cacheName)\n\n    var caches = tx.objectStore('caches')\n    var index = caches.index('cacheName')\n    var request = index.getAllKeys(IDBKeyRange.only(cacheName));\n\n    request.onsuccess = function(tx) {\n      for (let key of this.result) {\n        caches.delete(key)\n      }\n    }\n\n    return new Promise((rs, rj) => {\n      tx.oncomplete = () => rs(true)\n      tx.onerror = () => rj(false)\n    })\n  }\n\n\n  /**\n   * [has description]\n   * @return {Boolean} [description]\n   */\n  has(cacheName) {\n    return this.keys().then(keys => keys.includes(cacheName))\n  }\n\n\n  /**\n   * resolves with an array containing strings corresponding to all of the named\n   * Cache objects tracked by the CacheStorage.\n   * Use this method to iterate over a list of all the Cache objects.\n   *\n   * @return <Promise>Array keyList\n   */\n  async keys() {\n    const db = await openDB()\n\n    // Start a new transaction\n    var tx = db.transaction('storages', 'readonly')\n    var store = tx.objectStore('storages')\n    var keys = store.getAllKeys()\n\n    return new Promise(rs =>\n      keys.onsuccess = () => rs(keys.result)\n    )\n  }\n\n\n  /**\n   * Checks if a given Request is a key in any of the Cache objects\n   * that the CacheStorage object tracks and returns a Promise that\n   * resolves to that match.\n   *\n   * @return Promise\n   */\n  async match(...args) {\n    let keys = await this.keys()\n\n    for (let key of keys) {\n      let cache = await this.open(key)\n      let result = await cache.match(...args)\n      if (result) return result\n    }\n  }\n\n\n  /**\n   * Resolves to the Cache object matching the cacheName\n   * (a new cache is created if it doesn't exist.)\n   *\n   * @return {[type]} [description]\n   */\n  async open(cacheName) {\n    if (arguments.length < 1)\n      throw new TypeError(`${i} argument required, but only ${arguments.length} present.`)\n\n    const db = await openDB()\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('storages', 'readwrite')\n      const store = tx.objectStore('storages')\n\n      // Add some data\n      store.put({ cacheName });\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n\n    return new Cache(cacheName)\n  }\n\n\n  /**\n   * [description]\n   * @return {[type]} [description]\n   */\n  [Symbol.toStringTag]() {\n    return 'CacheStorage'\n  }\n}\n\nmodule.exports = {\n  Cache,\n  CacheStorage,\n  caches: new CacheStorage\n}\n"],"names":["map","WeakMap","wm","o","get","requires","i","args","length","TypeError","isReq","req","Request","openDB","Promise","rs","open","indexedDB","onupgradeneeded","db","result","createObjectStore","keyPath","autoIncrement","createIndex","unique","onsuccess","constructor","cacheName","set","this","match","_this","matchAll","_resp","options","method","tx","transaction","objectStore","index","openCursor","IDBKeyRange","only","cursor","url","value","reqUrl","initData","Object","assign","resUrl","res","Response","body","push","continue","oncomplete","add","request","_this5","addAll","requests","results","fetch","then","status","ok","test","clone","all","a","put","_this7","delete","split","varyHeaders","headers","includes","bodyUsed","folder","statusText","arrayBuffer","replace","reqMethod","rj","cache","onerror","error","ignoreMethod","r","caches","query","deleted","primaryKey","keys","ignoreSearch","undefined","getAll","search","response","CacheStorage","store","getAllKeys","key","has","_arguments6","Cache","Symbol","toStringTag"],"mappings":"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"}