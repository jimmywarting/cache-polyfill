{"version":3,"file":"cache.min.js","sources":["../src/cache.js","../src/cache-storage.js"],"sourcesContent":["const map = new WeakMap()\nconst wm = o => map.get(o)\n\nconst requires = (i, args) => {\n  if (args.length < i)\n    throw new TypeError(`${i} argument required, but only ${args.length} present.`)\n}\n\nconst isReq = req => req && req instanceof Request\nconst isRes = res => res && res instanceof Response\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = () => {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', { keyPath: 'cacheName' })\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass Cache {\n  constructor(cacheName) {\n    map.set(this, cacheName)\n  }\n\n  /**\n   * Returns a Promise that resolves to the response associated\n   * with the first matching request in the Cache object.\n   *\n   * @param  {[type]}  args [description]\n   * @return {Promise}      [description]\n   */\n  async match(...args) {\n    return (await this.matchAll(...args))[0]\n  }\n\n  // Returns a Promise that resolves to an array\n  // of all matching requests in the Cache object.\n  async matchAll(req, options = {}) {\n    if (req.method === 'HEAD') return []\n\n    const cacheName = wm(this)\n    const db = await openDB()\n    const result = []\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readonly')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const request = index.openCursor(IDBKeyRange.only(cacheName));\n    request.onsuccess = function() {\n      let cursor = this.result;\n\n      if (cursor) {\n        if ((req.url || req) === cursor.value.reqUrl) {\n          const initData = Object.assign({\n            url: cursor.value.resUrl\n          }, cursor.value)\n\n          const res = new Response(cursor.value.body, initData)\n          result.push(res)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(result)\n    )\n  }\n\n  // Takes a URL, retrieves it and adds the resulting response\n  // object to the given cache. This is fuctionally equivalent\n  // to calling fetch(), then using put() to add the results to the cache\n  async add(request) {\n    requires(1, arguments)\n    return this.addAll([request])\n  }\n\n  // Takes an array of URLs, retrieves them, and adds the\n  // resulting response objects to the given cache.\n  async addAll(requests) {\n    requires(1, arguments)\n\n    let results = []\n\n    for (let req of requests) {\n      req = new Request(req)\n\n      if (!/^((http|https):\\/\\/)/.test(req.url))\n        throw new TypeError(`Add/AddAll does not support schemes other than \"http\" or \"https\"`)\n\n      if (req.method !== 'GET')\n        throw new TypeError(`Add/AddAll only supports the GET request method`)\n\n      let clone = req.clone()\n\n      await fetch(req).then(res => {\n        if (res.status === 206)\n          throw new TypeError('Partial response (status code 206) is unsupported')\n\n        if (!res.ok)\n          throw new TypeError('Request failed')\n\n        results.push([req, res])\n      })\n    }\n\n    await Promise.all(results.map(a => this.put(...a)))\n  }\n\n\n  /**\n   * Takes both a request and its response and adds it to the given cache.\n   *\n   * @param  {Request|String}  req  [description]\n   * @param  {Response}        res  [description]\n   * @return {Promise}              [description]\n   */\n  async put(req, res) {\n    requires(2, arguments)\n\n    req = isReq(req) ? req : new Request(req)\n\n    await this.delete(req)\n\n    if (!/^((http|https):\\/\\/)/.test(req.url))\n      throw new TypeError(`Request scheme '${req.url.split(':')[0]}' is unsupported`)\n\n    if (req.method !== 'GET')\n      throw new TypeError(`Request method '${req.method}' is unsupported`)\n\n    if (res.status === 206)\n      throw new TypeError('Partial response (status code 206) is unsupported')\n\n    let varyHeaders = res.headers.get('Vary')\n\n    if (varyHeaders && varyHeaders.includes('*'))\n      throw new TypeError('Vary header contains *')\n\n    if (res.body != null)\n      if (res.bodyUsed)\n        throw new TypeError('Response body is already used')\n\n    let folder = wm(this)\n    let cache = {\n      cacheName: folder,\n      headers: [...res.headers],\n      status: res.status,\n      statusText: res.statusText,\n      body: await res.arrayBuffer(),\n      reqUrl: req.url.replace(/#.*$/,''),\n      resUrl: res.url.replace(/#.*$/,''),\n      reqMethod: req.method\n    }\n\n    const db = await openDB()\n\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('caches', 'readwrite')\n      const store = tx.objectStore('caches')\n\n      // Add some data\n      store.put(cache);\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n  }\n\n  // Finds the Cache entry whose key is the request, and if found,\n  // deletes the Cache entry and returns a Promise that resolves to true.\n  // If no Cache entry is found, it returns false.\n  async delete(request, options = {}) {\n    requires(1, arguments)\n    const cacheName = wm(this)\n\n    const { ignoreMethod } = options\n    const r = isReq(request) ? request : new Request(request)\n    if (!['GET', 'HEAD'].includes(r.method) && ignoreMethod)\n      return false\n\n    const { method } = r\n    const url = r.url.replace(/#.*$/,'')\n    const db = await openDB()\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readwrite')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const query = index.openCursor(IDBKeyRange.only(cacheName));\n\n    let deleted = false\n\n    query.onsuccess = function() {\n      const cursor = this.result;\n\n      if (cursor) {\n        if (url === cursor.value.reqUrl && (ignoreMethod || method === cursor.value.reqMethod)) {\n          deleted = true\n          caches.delete(cursor.primaryKey)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(deleted)\n    )\n  }\n\n  // Returns a Promise that resolves to an array of Cache keys.\n  async keys(request, options = {}) {\n    let url\n    const folder = wm(this)\n    const {\n      ignoreMethod = false,\n      ignoreSearch = false\n    } = options\n\n    // using new Request to normalize fragment and trailing slash\n    if (request !== undefined) {\n      request = new Request(request)\n\n      url = request.url.split('#')[0]\n\n      if (request.method !== 'GET' && !ignoreMethod) return []\n    }\n\n    const search = request === undefined ? a => a : a => a.filter(a => {\n      if (ignoreSearch) {\n        a = a.reqUrl.split('?')[0]\n        url = url.split('?')[0]\n      } else {\n        a = a.reqUrl\n      }\n\n      return a === url\n    })\n\n    const db = await openDB()\n\n    const responses = await new Promise(rs => {\n      const tx = db.transaction('caches', 'readonly')\n      const store = tx.objectStore('caches')\n      const cacheName = store.index('cacheName');\n      const request = cacheName.getAll(IDBKeyRange.only(folder))\n      request.onsuccess = () => rs(request.result)\n    })\n\n    return search(responses).map(response => new Request(response.reqUrl))\n  }\n}\n\nmodule.exports = Cache\n","const Cache = require('./cache')\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = function() {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', {keyPath: 'cacheName'})\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      const e = cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass CacheStorage {\n\n  /**\n   * [delete description]\n   * @return {[type]} [description]\n   */\n  async delete(cacheName) {\n    // Should resolve to false if there is nothing to delete\n    const keys = await this.keys()\n    if (!keys.includes(cacheName)) {\n      return false\n    }\n\n    const db = await openDB()\n\n    // Start a new transaction\n    var tx = db.transaction(['storages', 'caches'], 'readwrite')\n    var store = tx.objectStore('storages')\n    var request = store.delete(cacheName)\n\n    var caches = tx.objectStore('caches')\n    var index = caches.index('cacheName')\n    var request = index.getAllKeys(IDBKeyRange.only(cacheName));\n\n    request.onsuccess = function(tx) {\n      for (let key of this.result) {\n        caches.delete(key)\n      }\n    }\n\n    return new Promise((rs, rj) => {\n      tx.oncomplete = () => rs(true)\n      tx.onerror = () => rj(false)\n    })\n  }\n\n\n  /**\n   * [has description]\n   * @return {Boolean} [description]\n   */\n  has(cacheName) {\n    return this.keys().then(keys => keys.includes(cacheName))\n  }\n\n\n  /**\n   * resolves with an array containing strings corresponding to all of the named\n   * Cache objects tracked by the CacheStorage.\n   * Use this method to iterate over a list of all the Cache objects.\n   *\n   * @return <Promise>Array keyList\n   */\n  async keys() {\n    const db = await openDB()\n\n    // Start a new transaction\n    var tx = db.transaction('storages', 'readonly')\n    var store = tx.objectStore('storages')\n    var keys = store.getAllKeys()\n\n    return new Promise(rs =>\n      keys.onsuccess = () => rs(keys.result)\n    )\n  }\n\n\n  /**\n   * Checks if a given Request is a key in any of the Cache objects\n   * that the CacheStorage object tracks and returns a Promise that\n   * resolves to that match.\n   *\n   * @return Promise\n   */\n  async match(...args) {\n    let keys = await this.keys()\n\n    for (let key of keys) {\n      let cache = await this.open(key)\n      let result = await cache.match(...args)\n      if (result) return result\n    }\n  }\n\n\n  /**\n   * Resolves to the Cache object matching the cacheName\n   * (a new cache is created if it doesn't exist.)\n   *\n   * @return {[type]} [description]\n   */\n  async open(cacheName) {\n    if (arguments.length < 1)\n      throw new TypeError(`${i} argument required, but only ${arguments.length} present.`)\n\n    const db = await openDB()\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('storages', 'readwrite')\n      const store = tx.objectStore('storages')\n\n      // Add some data\n      store.put({ cacheName });\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n\n    return new Cache(cacheName)\n  }\n\n\n  /**\n   * [description]\n   * @return {[type]} [description]\n   */\n  [Symbol.toStringTag]() {\n    return 'CacheStorage'\n  }\n}\n\nmodule.exports = {\n  Cache,\n  CacheStorage,\n  caches: new CacheStorage\n}\n"],"names":["map","WeakMap","wm","o","get","requires","i","args","length","TypeError","isReq","req","Request","openDB","Promise","rs","open","indexedDB","onupgradeneeded","db","result","createObjectStore","keyPath","autoIncrement","createIndex","unique","onsuccess","cacheName","set","this","matchAll","method","tx","transaction","caches","objectStore","index","openCursor","IDBKeyRange","only","cursor","url","value","reqUrl","initData","Object","assign","resUrl","res","Response","body","push","oncomplete","request","addAll","requests","results","test","clone","fetch","then","status","ok","all","a","_this","put","split","varyHeaders","headers","includes","bodyUsed","folder","statusText","arrayBuffer","replace","cache","reqMethod","rj","onerror","error","options","ignoreMethod","r","query","deleted","primaryKey","ignoreSearch","undefined","search","filter","getAll","responses","response","CacheStorage","keys","getAllKeys","key","store","match","_args4","Cache","Symbol","toStringTag"],"mappings":"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"}