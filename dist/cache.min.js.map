{"version":3,"file":"cache.min.js","sources":["../src/cache.js","../src/cache-storage.js"],"sourcesContent":["const map = new WeakMap()\nconst wm = o => map.get(o)\n\nconst requires = (i, args) => {\n  if (args.length < i)\n    throw new TypeError(`${i} argument required, but only ${args.length} present.`)\n}\n\nconst isReq = req => req && req instanceof Request\nconst isRes = res => res && res instanceof Response\n\nfunction openDB () {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = () => {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', { keyPath: 'cacheName' })\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass Cache {\n  constructor(cacheName) {\n    map.set(this, cacheName)\n  }\n\n  /**\n   * Returns a Promise that resolves to the response associated\n   * with the first matching request in the Cache object.\n   *\n   * @param  {[type]}  args [description]\n   * @return {Promise}      [description]\n   */\n  async match (...args) {\n    return (await this.matchAll(...args))[0]\n  }\n\n  // Returns a Promise that resolves to an array\n  // of all matching requests in the Cache object.\n  async matchAll (req, options = {}) {\n    if (req.method === 'HEAD') return []\n\n    const cacheName = wm(this)\n    const db = await openDB()\n    const result = []\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readonly')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const request = index.openCursor(IDBKeyRange.only(cacheName));\n    request.onsuccess = function() {\n      let cursor = this.result;\n\n      if (cursor) {\n        if ((req.url || req) === cursor.value.reqUrl) {\n          const initData = Object.assign({\n            url: cursor.value.resUrl\n          }, cursor.value)\n\n          const res = new Response(cursor.value.body, initData)\n          result.push(res)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(result)\n    )\n  }\n\n  // Takes a URL, retrieves it and adds the resulting response\n  // object to the given cache. This is fuctionally equivalent\n  // to calling fetch(), then using put() to add the results to the cache\n  async add (request) {\n    requires(1, arguments)\n    return this.addAll([request])\n  }\n\n  // Takes an array of URLs, retrieves them, and adds the\n  // resulting response objects to the given cache.\n  async addAll(requests) {\n    requires(1, arguments)\n\n    let results = []\n\n    for (let req of requests) {\n      req = new Request(req)\n\n      if (!/^((http|https):\\/\\/)/.test(req.url))\n        throw new TypeError(`Add/AddAll does not support schemes other than \"http\" or \"https\"`)\n\n      if (req.method !== 'GET')\n        throw new TypeError(`Add/AddAll only supports the GET request method`)\n\n      let clone = req.clone()\n\n      await fetch(req).then(res => {\n        if (res.status === 206)\n          throw new TypeError('Partial response (status code 206) is unsupported')\n\n        if (!res.ok)\n          throw new TypeError('Request failed')\n\n        results.push([req, res])\n      })\n    }\n\n    await Promise.all(results.map(a => this.put(...a)))\n  }\n\n\n  /**\n   * Takes both a request and its response and adds it to the given cache.\n   *\n   * @param  {Request|String}  req  [description]\n   * @param  {Response}        res  [description]\n   * @return {Promise}              [description]\n   */\n  async put (req, res) {\n    requires(2, arguments)\n\n    req = isReq(req) ? req : new Request(req)\n\n    await this.delete(req)\n\n    if (!/^((http|https):\\/\\/)/.test(req.url))\n      throw new TypeError(`Request scheme '${req.url.split(':')[0]}' is unsupported`)\n\n    if (req.method !== 'GET')\n      throw new TypeError(`Request method '${req.method}' is unsupported`)\n\n    if (res.status === 206)\n      throw new TypeError('Partial response (status code 206) is unsupported')\n\n    let varyHeaders = res.headers.get('Vary')\n\n    if (varyHeaders && varyHeaders.includes('*'))\n      throw new TypeError('Vary header contains *')\n\n    if (res.body != null)\n      if (res.bodyUsed)\n        throw new TypeError('Response body is already used')\n\n    let folder = wm(this)\n    let cache = {\n      cacheName: folder,\n      headers: [...res.headers],\n      status: res.status,\n      statusText: res.statusText,\n      body: await res.arrayBuffer(),\n      reqUrl: req.url.replace(/#.*$/,''),\n      resUrl: res.url.replace(/#.*$/,''),\n      reqMethod: req.method\n    }\n\n    const db = await openDB()\n\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('caches', 'readwrite')\n      const store = tx.objectStore('caches')\n\n      // Add some data\n      store.put(cache);\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n  }\n\n  // Finds the Cache entry whose key is the request, and if found,\n  // deletes the Cache entry and returns a Promise that resolves to true.\n  // If no Cache entry is found, it returns false.\n  async delete(request, options = {}) {\n    requires(1, arguments)\n    const cacheName = wm(this)\n\n    const { ignoreMethod } = options\n    const r = isReq(request) ? request : new Request(request)\n    if (!['GET', 'HEAD'].includes(r.method) && ignoreMethod)\n      return false\n\n    const { method } = r\n    const url = r.url.replace(/#.*$/,'')\n    const db = await openDB()\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readwrite')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const query = index.openCursor(IDBKeyRange.only(cacheName));\n\n    let deleted = false\n\n    query.onsuccess = function() {\n      const cursor = this.result;\n\n      if (cursor) {\n        if (url === cursor.value.reqUrl && (ignoreMethod || method === cursor.value.reqMethod)) {\n          deleted = true\n          caches.delete(cursor.primaryKey)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(deleted)\n    )\n  }\n\n  // Returns a Promise that resolves to an array of Cache keys.\n  async keys(request, options = {}) {\n    let url\n    const folder = wm(this)\n    const {\n      ignoreMethod = false,\n      ignoreSearch = false\n    } = options\n\n    // using new Request to normalize fragment and trailing slash\n    if (request !== undefined) {\n      request = new Request(request)\n\n      url = request.url.split('#')[0]\n\n      if (request.method !== 'GET' && !ignoreMethod) return []\n    }\n\n    const search = request === undefined ? a => a : a => a.filter(a => {\n      if (ignoreSearch) {\n        a = a.reqUrl.split('?')[0]\n        url = url.split('?')[0]\n      } else {\n        a = a.reqUrl\n      }\n\n      return a === url\n    })\n\n    const db = await openDB()\n\n    const responses = await new Promise(rs => {\n      const tx = db.transaction('caches', 'readonly')\n      const store = tx.objectStore('caches')\n      const cacheName = store.index('cacheName');\n      const request = cacheName.getAll(IDBKeyRange.only(folder))\n      request.onsuccess = () => rs(request.result)\n    })\n\n    return search(responses).map(response => new Request(response.reqUrl))\n  }\n}\n\nmodule.exports = Cache\n","const Cache = require('./cache')\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = function() {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', {keyPath: 'cacheName'})\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      const e = cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass CacheStorage {\n\n  /**\n   * [delete description]\n   * @return {[type]} [description]\n   */\n  async delete (cacheName) {\n    // Should resolve to false if there is nothing to delete\n    const keys = await this.keys()\n    if (!keys.includes(cacheName)) {\n      return false\n    }\n\n    const db = await openDB()\n\n    // Start a new transaction\n    const tx = db.transaction(['storages', 'caches'], 'readwrite')\n    const store = tx.objectStore('storages')\n    store.delete(cacheName)\n\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const request = index.getAllKeys(IDBKeyRange.only(cacheName));\n\n    request.onsuccess = function(tx) {\n      for (let key of this.result) {\n        caches.delete(key)\n      }\n    }\n\n    return new Promise((rs, rj) => {\n      tx.oncomplete = () => rs(true)\n      tx.onerror = () => rj(false)\n    })\n  }\n\n\n  /**\n   * [has description]\n   * @return {Boolean} [description]\n   */\n  has (cacheName) {\n    return this.keys().then(keys => keys.includes(cacheName))\n  }\n\n\n  /**\n   * resolves with an array containing strings corresponding to all of the named\n   * Cache objects tracked by the CacheStorage.\n   * Use this method to iterate over a list of all the Cache objects.\n   *\n   * @return <Promise>Array keyList\n   */\n  async keys () {\n    const db = await openDB()\n\n    // Start a new transaction\n    const keys = db.transaction('storages', 'readonly').objectStore('storages').getAllKeys()\n\n    return new Promise(rs =>\n      keys.onsuccess = () => rs(keys.result)\n    )\n  }\n\n\n  /**\n   * Checks if a given Request is a key in any of the Cache objects\n   * that the CacheStorage object tracks and returns a Promise that\n   * resolves to that match.\n   *\n   * @return Promise\n   */\n  async match(...args) {\n    let keys = await this.keys()\n\n    for (let key of keys) {\n      let cache = await this.open(key)\n      let result = await cache.match(...args)\n      if (result) return result\n    }\n  }\n\n\n  /**\n   * Resolves to the Cache object matching the cacheName\n   * (a new cache is created if it doesn't exist.)\n   *\n   * @return {[type]} [description]\n   */\n  async open(cacheName) {\n    if (arguments.length < 1)\n      throw new TypeError(`${i} argument required, but only ${arguments.length} present.`)\n\n    const db = await openDB()\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('storages', 'readwrite')\n      const store = tx.objectStore('storages')\n\n      // Add some data\n      store.put({ cacheName });\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n\n    return new Cache(cacheName)\n  }\n\n\n  /**\n   * [description]\n   * @return {[type]} [description]\n   */\n  [Symbol.toStringTag]() {\n    return 'CacheStorage'\n  }\n}\n\nmodule.exports = {\n  Cache,\n  CacheStorage,\n  caches: new CacheStorage\n}\n"],"names":["map","WeakMap","wm","o","get","requires","i","args","length","TypeError","isReq","req","Request","openDB","Promise","rs","open","indexedDB","onupgradeneeded","db","result","createObjectStore","keyPath","autoIncrement","createIndex","unique","onsuccess","cacheName","set","this","matchAll","method","tx","transaction","objectStore","index","openCursor","IDBKeyRange","only","cursor","url","value","reqUrl","initData","Object","assign","resUrl","res","Response","body","push","oncomplete","request","arguments","addAll","requests","results","test","clone","fetch","then","status","ok","all","a","_this","put","split","varyHeaders","headers","includes","bodyUsed","folder","cache","statusText","arrayBuffer","replace","reqMethod","rj","onerror","error","options","ignoreMethod","r","caches","query","deleted","primaryKey","ignoreSearch","undefined","search","filter","responses","getAll","response","CacheStorage","keys","getAllKeys","key","match","Cache","Symbol","toStringTag"],"mappings":"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"}