{"version":3,"file":"cache.min.js","sources":["../src/cache.js","../src/cache-storage.js"],"sourcesContent":["const map = new WeakMap()\nconst wm = o => map.get(o)\n\nconst requires = (i, args) => {\n  if (args.length < i)\n    throw new TypeError(`${i} argument required, but only ${args.length} present.`)\n}\n\nconst isReq = req => req && req instanceof Request\nconst isRes = res => res && res instanceof Response\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = () => {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', { keyPath: 'cacheName' })\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass Cache {\n  constructor(cacheName) {\n    map.set(this, cacheName)\n  }\n\n  /**\n   * Returns a Promise that resolves to the response associated\n   * with the first matching request in the Cache object.\n   *\n   * @param  {[type]}  args [description]\n   * @return {Promise}      [description]\n   */\n  async match(...args) {\n    return (await this.matchAll(...args))[0]\n  }\n\n  // Returns a Promise that resolves to an array\n  // of all matching requests in the Cache object.\n  async matchAll(req, options = {}) {\n    if (req.method === 'HEAD') return []\n\n    const cacheName = wm(this)\n    const db = await openDB()\n    const result = []\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readonly')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const request = index.openCursor(IDBKeyRange.only(cacheName));\n    request.onsuccess = function() {\n      let cursor = this.result;\n\n      if (cursor) {\n        if ((req.url || req) === cursor.value.reqUrl) {\n          const initData = Object.assign({\n            url: cursor.value.resUrl\n          }, cursor.value)\n\n          const res = new Response(cursor.value.body, initData)\n          result.push(res)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(result)\n    )\n  }\n\n  // Takes a URL, retrieves it and adds the resulting response\n  // object to the given cache. This is fuctionally equivalent\n  // to calling fetch(), then using put() to add the results to the cache\n  async add(request) {\n    requires(1, arguments)\n    return this.addAll([request])\n  }\n\n  // Takes an array of URLs, retrieves them, and adds the\n  // resulting response objects to the given cache.\n  async addAll(requests) {\n    requires(1, arguments)\n\n    let results = []\n\n    for (let req of requests) {\n      req = new Request(req)\n\n      if (!/^((http|https):\\/\\/)/.test(req.url))\n        throw new TypeError(`Add/AddAll does not support schemes other than \"http\" or \"https\"`)\n\n      if (req.method !== 'GET')\n        throw new TypeError(`Add/AddAll only supports the GET request method`)\n\n      let clone = req.clone()\n\n      await fetch(req).then(res => {\n        if (res.status === 206)\n          throw new TypeError('Partial response (status code 206) is unsupported')\n\n        if (!res.ok)\n          throw new TypeError('Request failed')\n\n        results.push([req, res])\n      })\n    }\n\n    await Promise.all(results.map(a => this.put(...a)))\n  }\n\n\n  /**\n   * Takes both a request and its response and adds it to the given cache.\n   *\n   * @param  {Request|String}  req  [description]\n   * @param  {Response}        res  [description]\n   * @return {Promise}              [description]\n   */\n  async put(req, res) {\n    requires(2, arguments)\n\n    req = isReq(req) ? req : new Request(req)\n\n    await this.delete(req)\n\n    if (!/^((http|https):\\/\\/)/.test(req.url))\n      throw new TypeError(`Request scheme '${req.url.split(':')[0]}' is unsupported`)\n\n    if (req.method !== 'GET')\n      throw new TypeError(`Request method '${req.method}' is unsupported`)\n\n    if (res.status === 206)\n      throw new TypeError('Partial response (status code 206) is unsupported')\n\n    let varyHeaders = res.headers.get('Vary')\n\n    if (varyHeaders && varyHeaders.includes('*'))\n      throw new TypeError('Vary header contains *')\n\n    if (res.body != null)\n      if (res.bodyUsed)\n        throw new TypeError('Response body is already used')\n\n    let folder = wm(this)\n    let cache = {\n      cacheName: folder,\n      headers: [...res.headers],\n      status: res.status,\n      statusText: res.statusText,\n      body: await res.arrayBuffer(),\n      reqUrl: req.url.replace(/#.*$/,''),\n      resUrl: res.url.replace(/#.*$/,''),\n      reqMethod: req.method\n    }\n\n    const db = await openDB()\n\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('caches', 'readwrite')\n      const store = tx.objectStore('caches')\n\n      // Add some data\n      store.put(cache);\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n  }\n\n  // Finds the Cache entry whose key is the request, and if found,\n  // deletes the Cache entry and returns a Promise that resolves to true.\n  // If no Cache entry is found, it returns false.\n  async delete(request, options = {}) {\n    requires(1, arguments)\n    const cacheName = wm(this)\n\n    const { ignoreMethod } = options\n    const r = isReq(request) ? request : new Request(request)\n    if (!['GET', 'HEAD'].includes(r.method) && ignoreMethod)\n      return false\n\n    const { method } = r\n    const url = r.url.replace(/#.*$/,'')\n    const db = await openDB()\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readwrite')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const query = index.openCursor(IDBKeyRange.only(cacheName));\n\n    let deleted = false\n\n    query.onsuccess = function() {\n      const cursor = this.result;\n\n      if (cursor) {\n        if (url === cursor.value.reqUrl && (ignoreMethod || method === cursor.value.reqMethod)) {\n          deleted = true\n          caches.delete(cursor.primaryKey)\n        }\n        cursor.continue();\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(deleted)\n    )\n  }\n\n  // Returns a Promise that resolves to an array of Cache keys.\n  async keys(request, options = {}) {\n    let url\n    const folder = wm(this)\n    const {\n      ignoreMethod = false,\n      ignoreSearch = false\n    } = options\n\n    // using new Request to normalize fragment and trailing slash\n    if (request !== undefined) {\n      request = new Request(request)\n\n      url = request.url.split('#')[0]\n\n      if (request.method !== 'GET' && !ignoreMethod) return []\n    }\n\n    const search = request === undefined ? a => a : a => a.filter(a => {\n      if (ignoreSearch) {\n        a = a.reqUrl.split('?')[0]\n        url = url.split('?')[0]\n      } else {\n        a = a.reqUrl\n      }\n\n      return a === url\n    })\n\n    const db = await openDB()\n\n    const responses = await new Promise(rs => {\n      const tx = db.transaction('caches', 'readonly')\n      const store = tx.objectStore('caches')\n      const cacheName = store.index('cacheName');\n      const request = cacheName.getAll(IDBKeyRange.only(folder))\n      request.onsuccess = () => rs(request.result)\n    })\n\n    return search(responses).map(response => new Request(response.reqUrl))\n  }\n}\n\nmodule.exports = Cache\n","const Cache = require('./cache')\n\nfunction openDB() {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = function() {\n      const db = open.result;\n      // cointains all storage containsers\n      db.createObjectStore('storages', {keyPath: 'cacheName'})\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      const e = cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result);\n    }\n  })\n}\n\nclass CacheStorage {\n\n  /**\n   * [delete description]\n   * @return {[type]} [description]\n   */\n  async delete(cacheName) {\n    // Should resolve to false if there is nothing to delete\n    const keys = await this.keys()\n    if (!keys.includes(cacheName)) {\n      return false\n    }\n\n    const db = await openDB()\n\n    // Start a new transaction\n    var tx = db.transaction(['storages', 'caches'], 'readwrite')\n    var store = tx.objectStore('storages')\n    var request = store.delete(cacheName)\n\n    var caches = tx.objectStore('caches')\n    var index = caches.index('cacheName')\n    var request = index.getAllKeys(IDBKeyRange.only(cacheName));\n\n    request.onsuccess = function(tx) {\n      for (let key of this.result) {\n        caches.delete(key)\n      }\n    }\n\n    return new Promise((rs, rj) => {\n      tx.oncomplete = () => rs(true)\n      tx.onerror = () => rj(false)\n    })\n  }\n\n\n  /**\n   * [has description]\n   * @return {Boolean} [description]\n   */\n  has(cacheName) {\n    return this.keys().then(keys => keys.includes(cacheName))\n  }\n\n\n  /**\n   * resolves with an array containing strings corresponding to all of the named\n   * Cache objects tracked by the CacheStorage.\n   * Use this method to iterate over a list of all the Cache objects.\n   *\n   * @return <Promise>Array keyList\n   */\n  async keys() {\n    const db = await openDB()\n\n    // Start a new transaction\n    var tx = db.transaction('storages', 'readonly')\n    var store = tx.objectStore('storages')\n    var keys = store.getAllKeys()\n\n    return new Promise(rs =>\n      keys.onsuccess = () => rs(keys.result)\n    )\n  }\n\n\n  /**\n   * Checks if a given Request is a key in any of the Cache objects\n   * that the CacheStorage object tracks and returns a Promise that\n   * resolves to that match.\n   *\n   * @return Promise\n   */\n  async match(...args) {\n    let keys = await this.keys()\n\n    for (let key of keys) {\n      let cache = await this.open(key)\n      let result = await cache.match(...args)\n      if (result) return result\n    }\n  }\n\n\n  /**\n   * Resolves to the Cache object matching the cacheName\n   * (a new cache is created if it doesn't exist.)\n   *\n   * @return {[type]} [description]\n   */\n  async open(cacheName) {\n    if (arguments.length < 1)\n      throw new TypeError(`${i} argument required, but only ${arguments.length} present.`)\n\n    const db = await openDB()\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('storages', 'readwrite')\n      const store = tx.objectStore('storages')\n\n      // Add some data\n      store.put({ cacheName });\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(transaction.error)\n    })\n\n    return new Cache(cacheName)\n  }\n\n\n  /**\n   * [description]\n   * @return {[type]} [description]\n   */\n  [Symbol.toStringTag]() {\n    return 'CacheStorage'\n  }\n}\n\nmodule.exports = {\n  Cache,\n  CacheStorage,\n  caches: new CacheStorage\n}\n"],"names":["value","then","map","WeakMap","wm","o","get","requires","i","args","length","TypeError","isReq","req","Request","bind","result","_isSettledPact","thenable","s","e","pact","body","openDB","Promise","rs","open","indexedDB","onupgradeneeded","db","createObjectStore","keyPath","autoIncrement","createIndex","unique","onsuccess","cacheName","set","this","_this2","matchAll","_this$matchAll","method","tx","transaction","objectStore","index","openCursor","IDBKeyRange","only","cursor","url","reqUrl","initData","Object","assign","resUrl","res","Response","push","oncomplete","request","arguments","_this6","addAll","requests","results","test","clone","fetch","status","ok","all","a","_this8","put","_this10","split","varyHeaders","headers","includes","bodyUsed","folder","statusText","arrayBuffer","cache","replace","reqMethod","rj","onerror","error","options","ignoreMethod","r","caches","query","deleted","primaryKey","ignoreSearch","undefined","search","filter","getAll","responses","response","v","_this","CacheStorage","keys","getAllKeys","key","store","_this4","match","_arguments2","Cache","Symbol","toStringTag"],"mappings":"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"}